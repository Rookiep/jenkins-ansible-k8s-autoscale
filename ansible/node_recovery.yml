---
- name: Kubernetes Node Health Check and Confirmed Auto-Restart
  hosts: localhost
  gather_facts: true
  vars:
    max_retries: 3
    retry_delay: 30
    wait_timeout: 300

  tasks:
    - name: Check cluster accessibility
      command: kubectl cluster-info
      register: cluster_status
      ignore_errors: yes
      changed_when: false

    - name: Initialize variables
      set_fact:
        unhealthy_nodes: []
        recovered_nodes: []
        failed_nodes: []
        cluster_accessible: "{{ cluster_status is succeeded }}"

    - name: Get all nodes status
      shell: |
        kubectl get nodes --no-headers -o wide
      register: all_nodes
      ignore_errors: yes
      changed_when: false
      when: cluster_status is succeeded

    - name: Identify unhealthy nodes
      shell: |
        kubectl get nodes --no-headers | awk '$2 != "Ready" {print $1}'
      register: unhealthy_nodes_result
      ignore_errors: yes
      changed_when: false
      when: cluster_status is succeeded

    - name: Update unhealthy nodes list
      set_fact:
        unhealthy_nodes: "{{ unhealthy_nodes_result.stdout_lines }}"
      when: 
        - cluster_status is succeeded
        - unhealthy_nodes_result is succeeded

    - name: Display initial health status
      debug:
        msg: |
          ğŸ¥ KUBERNETES NODE HEALTH REPORT
          ================================
          ğŸ“… Timestamp: {{ ansible_date_time.iso8601 }}
          ğŸ”— Cluster Access: {{ "HEALTHY" if cluster_status is succeeded else "UNAVAILABLE" }}
          ğŸ“Š Total Nodes: {{ all_nodes.stdout_lines | length if all_nodes is succeeded else 'UNKNOWN' }}
          âš ï¸ Unhealthy Nodes: {{ unhealthy_nodes | length }}
          {% if unhealthy_nodes | length > 0 %}
          ğŸ”´ Unhealthy Nodes: {{ unhealthy_nodes | join(', ') }}
          {% endif %}
          {% if cluster_status is failed %}
          âŒ Cannot access Kubernetes cluster
          ğŸ’¡ Solution: Configure kubectl or start Kubernetes cluster
          {% endif %}

    - name: Confirm node restart for unhealthy nodes
      pause:
        prompt: |
          ğŸš¨ CONFIRM NODE RESTART REQUIRED
          ================================
          Unhealthy nodes detected: {{ unhealthy_nodes | join(', ') }}
          
          This will perform the following actions:
          1. âœ… Cordon nodes (prevent new pods)
          2. âœ… Drain nodes (safely evict pods) 
          3. ğŸ”„ Restart nodes
          4. â±ï¸ Wait for nodes to become Ready
          5. âœ… Uncordon nodes (allow scheduling)
          
          Type 'YES' to proceed with node restart:
        echo: yes
      when: unhealthy_nodes | length > 0 and cluster_status is succeeded

    - name: Execute node restart procedure
      block:
        - name: Step 1: Cordon unhealthy nodes
          shell: |
            kubectl cordon "{{ item }}"
          loop: "{{ unhealthy_nodes }}"
          ignore_errors: yes
          changed_when: false

        - name: Step 2: Drain unhealthy nodes (safely evict pods)
          shell: |
            timeout 600 kubectl drain "{{ item }}" --ignore-daemonsets --delete-emptydir-data --force --grace-period=300
          loop: "{{ unhealthy_nodes }}"
          register: drain_results
          ignore_errors: yes
          retries: "{{ max_retries }}"
          delay: "{{ retry_delay }}"

        - name: Step 3: Restart nodes based on environment
          block:
            - name: Restart Minikube node
              shell: |
                echo "Restarting Minikube node..."
                minikube node stop && minikube node start
              when: "'minikube' in unhealthy_nodes[0]"
              ignore_errors: yes

            - name: Restart using system reboot (generic)
              shell: |
                echo "Simulating system reboot for node: {{ item }}"
                # In production, this would be actual reboot command:
                # ssh {{ item }} 'sudo reboot'
                sleep 10
              loop: "{{ unhealthy_nodes }}"
              when: "'minikube' not in unhealthy_nodes[0]"
              ignore_errors: yes

        - name: Step 4: Wait for nodes to become Ready
          shell: |
            kubectl wait --for=condition=Ready node/{{ item }} --timeout={{ wait_timeout }}s
          loop: "{{ unhealthy_nodes }}"
          register: wait_results
          ignore_errors: yes
          retries: "{{ max_retries }}"
          delay: "{{ retry_delay }}"

        - name: Step 5: Uncordon recovered nodes
          shell: |
            kubectl uncordon "{{ item }}"
          loop: "{{ unhealthy_nodes }}"
          ignore_errors: yes
          changed_when: false

        - name: Track recovery status
          set_fact:
            recovered_nodes: "{{ recovered_nodes + [item.item] }}"
          loop: "{{ wait_results.results }}"
          when: item is succeeded
          loop_control:
            label: "{{ item.item }}"

        - name: Track failed recoveries
          set_fact:
            failed_nodes: "{{ failed_nodes + [item.item] }}"
          loop: "{{ wait_results.results }}"
          when: item is failed
          loop_control:
            label: "{{ item.item }}"

      when: unhealthy_nodes | length > 0 and cluster_status is succeeded

    - name: Verify final node status
      shell: |
        kubectl get nodes -o wide
      register: final_node_status
      ignore_errors: yes
      changed_when: false
      when: cluster_status is succeeded

    - name: Display recovery results
      debug:
        msg: |
          ğŸ”„ NODE RECOVERY RESULTS
          ========================
          ğŸ“… Recovery Time: {{ ansible_date_time.iso8601 }}
          ğŸ”´ Initially Unhealthy: {{ unhealthy_nodes | length }} nodes
          âœ… Successfully Recovered: {{ recovered_nodes | length }} nodes
          âŒ Failed to Recover: {{ failed_nodes | length }} nodes
          
          {% if recovered_nodes | length > 0 %}
          ğŸŸ¢ Recovered Nodes: {{ recovered_nodes | join(', ') }}
          {% endif %}
          
          {% if failed_nodes | length > 0 %}
          ğŸ”´ Failed Nodes (manual intervention required): {{ failed_nodes | join(', ') }}
          {% endif %}
          
          {% if unhealthy_nodes | length == 0 %}
          ğŸ‰ All nodes are healthy - no recovery needed!
          {% endif %}

    - name: Generate recovery report
      debug:
        msg: |
          ğŸ“‹ NODE RECOVERY COMPLETION REPORT
          =================================
          ğŸ Status: RECOVERY OPERATION COMPLETED
          â±ï¸ Duration: {{ ansible_date_time.iso8601 }}
          ğŸ“Š Initial State: {{ unhealthy_nodes | length }} unhealthy nodes
          ğŸ“ˆ Final State: {{ recovered_nodes | length }} recovered, {{ failed_nodes | length }} failed
          
          {% if recovered_nodes | length > 0 %}
          âœ… SUCCESS: {{ recovered_nodes | length }} node(s) automatically recovered
          Actions performed:
          - Cordoned nodes to prevent scheduling
          - Drained pods safely with grace period
          - Restarted node components
          - Waited for node readiness
          - Uncordoned nodes for scheduling
          {% endif %}
          
          {% if failed_nodes | length > 0 %}
          âš ï¸ ATTENTION REQUIRED: {{ failed_nodes | length }} node(s) need manual intervention
          Recommended actions:
          1. Check node hardware/network
          2. Verify kubelet service status
          3. Review system logs
          4. Consider manual reboot
          {% endif %}
          
          ğŸ¯ NEXT STEPS: Monitor node stability for next 24 hours

    - name: No unhealthy nodes message
      debug:
        msg: |
          âœ… ALL NODES HEALTHY
          ===================
          No unhealthy nodes detected at {{ ansible_date_time.iso8601 }}
          All Kubernetes nodes are in Ready state
          System is operating normally
      when: unhealthy_nodes | length == 0 and cluster_status is succeeded

    - name: Cluster setup instructions
      debug:
        msg: |
          ğŸ”§ KUBERNETES SETUP GUIDE
          ========================
          {% if cluster_status is failed %}
          To enable Kubernetes functionality:
          
          1. ğŸ“¥ Install Minikube:
             curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
             sudo install minikube-linux-amd64 /usr/local/bin/minikube
          
          2. ğŸš€ Start Cluster:
             minikube start
          
          3. âœ… Verify:
             kubectl get nodes
          
          4. âš™ï¸ Configure access for remote clusters
          {% else %}
          âœ… Kubernetes cluster is operational
          âœ… Node health monitoring is active
          âœ… Auto-recovery system is ready
          {% endif %}

  handlers:
    - name: send recovery notification
      debug:
        msg: "ğŸ“¢ Recovery notification would be sent for {{ recovered_nodes | length }} nodes"
      listen: "recovery completed"